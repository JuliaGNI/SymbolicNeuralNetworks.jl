<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SymbolicNeuralNetworks.jl</title><meta name="title" content="Home · SymbolicNeuralNetworks.jl"/><meta property="og:title" content="Home · SymbolicNeuralNetworks.jl"/><meta property="twitter:title" content="Home · SymbolicNeuralNetworks.jl"/><meta name="description" content="Documentation for SymbolicNeuralNetworks.jl."/><meta property="og:description" content="Documentation for SymbolicNeuralNetworks.jl."/><meta property="twitter:description" content="Documentation for SymbolicNeuralNetworks.jl."/><meta property="og:url" content="https://JuliaGNI.github.io/SymbolicNeuralNetworks.jl/"/><meta property="twitter:url" content="https://JuliaGNI.github.io/SymbolicNeuralNetworks.jl/"/><link rel="canonical" href="https://JuliaGNI.github.io/SymbolicNeuralNetworks.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SymbolicNeuralNetworks.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="symbolic_neural_networks/">Vanilla Symbolic Neural Network</a></li><li><a class="tocitem" href="double_derivative/">Double Derivative</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/main/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SymbolicNeuralNetworks"><a class="docs-heading-anchor" href="#SymbolicNeuralNetworks">SymbolicNeuralNetworks</a><a id="SymbolicNeuralNetworks-1"></a><a class="docs-heading-anchor-permalink" href="#SymbolicNeuralNetworks" title="Permalink"></a></h1><p><code>SymbolicNeuralNetworks</code> is a library for creating symbolic representations of relatively small neural networks on whose basis more complicated expressions can be build. It should mostly be used together with other packages like <a href="https://github.com/JuliaGNI/GeometricMachineLearning.jl"><code>GeometricMachineLearning</code></a> and <a href="https://github.com/JuliaGNI/GeometricIntegrators.jl"><code>GeometricIntegrators</code></a>.</p><ul><li><a href="#SymbolicNeuralNetworks.Derivative"><code>SymbolicNeuralNetworks.Derivative</code></a></li><li><a href="#SymbolicNeuralNetworks.Gradient"><code>SymbolicNeuralNetworks.Gradient</code></a></li><li><a href="#SymbolicNeuralNetworks.Jacobian"><code>SymbolicNeuralNetworks.Jacobian</code></a></li><li><a href="#SymbolicNeuralNetworks.SymbolicNeuralNetwork"><code>SymbolicNeuralNetworks.SymbolicNeuralNetwork</code></a></li><li><a href="#SymbolicNeuralNetworks.SymbolicPullback"><code>SymbolicNeuralNetworks.SymbolicPullback</code></a></li><li><a href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr, Symbolics.Arr}"><code>SymbolicNeuralNetworks._build_nn_function</code></a></li><li><a href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr}"><code>SymbolicNeuralNetworks._build_nn_function</code></a></li><li><a href="#SymbolicNeuralNetworks._get_contents-Tuple{NamedTuple}"><code>SymbolicNeuralNetworks._get_contents</code></a></li><li><a href="#SymbolicNeuralNetworks._get_params-Tuple{NamedTuple}"><code>SymbolicNeuralNetworks._get_params</code></a></li><li><a href="#SymbolicNeuralNetworks._modify_integer-Tuple{AbstractString}"><code>SymbolicNeuralNetworks._modify_integer</code></a></li><li><a href="#SymbolicNeuralNetworks._modify_integer2-Tuple{AbstractString}"><code>SymbolicNeuralNetworks._modify_integer2</code></a></li><li><a href="#SymbolicNeuralNetworks._reduce_code-Tuple{Expr}"><code>SymbolicNeuralNetworks._reduce_code</code></a></li><li><a href="#SymbolicNeuralNetworks.apply_element_wise-Tuple{AbstractArray, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{AbstractArray}}"><code>SymbolicNeuralNetworks.apply_element_wise</code></a></li><li><a href="#SymbolicNeuralNetworks.apply_element_wise-Tuple{AbstractNeuralNetworks.NeuralNetworkParameters, AbstractNeuralNetworks.NeuralNetworkParameters, Any}"><code>SymbolicNeuralNetworks.apply_element_wise</code></a></li><li><a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{Any, AbstractSymbolicNeuralNetwork, Any}"><code>SymbolicNeuralNetworks.build_nn_function</code></a></li><li><a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>SymbolicNeuralNetworks.build_nn_function</code></a></li><li><a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{AbstractArray{&lt;:Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>SymbolicNeuralNetworks.build_nn_function</code></a></li><li><a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}"><code>SymbolicNeuralNetworks.build_nn_function</code></a></li><li><a href="#SymbolicNeuralNetworks.derivative-Tuple{SymbolicNeuralNetworks.Gradient}"><code>SymbolicNeuralNetworks.derivative</code></a></li><li><a href="#SymbolicNeuralNetworks.fix_create_array-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.fix_create_array</code></a></li><li><a href="#SymbolicNeuralNetworks.fix_map_reduce-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.fix_map_reduce</code></a></li><li><a href="#SymbolicNeuralNetworks.function_valued_parameters-Tuple{AbstractNeuralNetworks.NeuralNetworkParameters, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>SymbolicNeuralNetworks.function_valued_parameters</code></a></li><li><a href="#SymbolicNeuralNetworks.make_kernel-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.make_kernel</code></a></li><li><a href="#SymbolicNeuralNetworks.make_kernel2-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.make_kernel2</code></a></li><li><a href="#SymbolicNeuralNetworks.modify_input_arguments-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.modify_input_arguments</code></a></li><li><a href="#SymbolicNeuralNetworks.modify_input_arguments2-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.modify_input_arguments2</code></a></li><li><a href="#SymbolicNeuralNetworks.rewrite_arguments-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.rewrite_arguments</code></a></li><li><a href="#SymbolicNeuralNetworks.rewrite_arguments2-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.rewrite_arguments2</code></a></li><li><a href="#SymbolicNeuralNetworks.symbolic_pullback-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}"><code>SymbolicNeuralNetworks.symbolic_pullback</code></a></li><li><a href="#SymbolicNeuralNetworks.symboliccounter!-Tuple{Dict, Symbol}"><code>SymbolicNeuralNetworks.symboliccounter!</code></a></li><li><a href="#SymbolicNeuralNetworks.symbolize!"><code>SymbolicNeuralNetworks.symbolize!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.Derivative" href="#SymbolicNeuralNetworks.Derivative"><code>SymbolicNeuralNetworks.Derivative</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Derivative</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/derivatives/derivative.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.Gradient" href="#SymbolicNeuralNetworks.Gradient"><code>SymbolicNeuralNetworks.Gradient</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Gradient &lt;: Derivative</code></pre><p>Computes and stores the gradient of a symbolic function with respect to the parameters of a <a href="#SymbolicNeuralNetworks.SymbolicNeuralNetwork"><code>SymbolicNeuralNetwork</code></a>.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">Gradient(output, nn)</code></pre><p>Differentiate the symbolic <code>output</code> with respect to the parameters of <code>nn</code>.</p><pre><code class="nohighlight hljs">Gradient(nn)</code></pre><p>Compute the symbolic output of <code>nn</code> and differentiate it with respect to the parameters of <code>nn</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: SymbolicNeuralNetwork, Gradient, derivative
using AbstractNeuralNetworks
using Latexify: latexify

c = Chain(Dense(2, 1, tanh))
nn = SymbolicNeuralNetwork(c)
(Gradient(nn) |&gt; derivative)[1].L1.b |&gt; latexify

# output

L&quot;\begin{equation}
\left[
\begin{array}{c}
1 - \tanh^{2}\left( \mathtt{W\_2}_{1} + \mathtt{W\_1}_{1,1} \mathtt{sinput}_{1} + \mathtt{W\_1}_{1,2} \mathtt{sinput}_{2} \right) \\
\end{array}
\right]
\end{equation}
&quot;</code></pre><p><strong>Implementation</strong></p><p>Internally the constructors are using <a href="#SymbolicNeuralNetworks.symbolic_pullback-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}"><code>symbolic_pullback</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/derivatives/gradient.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.Jacobian" href="#SymbolicNeuralNetworks.Jacobian"><code>SymbolicNeuralNetworks.Jacobian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Jacobian &lt;: Derivative</code></pre><p>An instance of <a href="#SymbolicNeuralNetworks.Derivative"><code>Derivative</code></a>. Computes the derivatives of a neural network with respect to its inputs.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">Jacobian(output, nn)
Jacobian(nn)</code></pre><p>Compute the jacobian of a <a href="#SymbolicNeuralNetworks.SymbolicNeuralNetwork"><code>SymbolicNeuralNetwork</code></a> with respect to the input arguments.</p><p>The output of <code>Jacobian</code> consists of a <code>NamedTuple</code> that has the following keys:</p><ol><li>a symbolic expression of the input (keyword <code>x</code>),</li><li>a symbolic expression of the output (keyword <code>soutput</code>),</li><li>a symbolic expression of the gradient (keyword <code>s∇output</code>).</li></ol><p>If <code>output</code> is not supplied as an input argument than it is taken to be:</p><pre><code class="language-julia hljs">soutput = nn.model(nn.input, params(nn))</code></pre><p><strong>Implementation</strong></p><p>For a function <span>$f:\mathbb{R}^n\to\mathbb{R}^m$</span> we choose the following convention for the Jacobian:</p><p class="math-container">\[\square_{ij} = \frac{\partial}{\partial{}x_j}f_i, \text{ i.e. } \square \in \mathbb{R}^{m\times{}n}\]</p><p>This is also used by <a href="https://github.com/FluxML/Zygote.jl"><code>Zygote</code></a> and <a href="https://github.com/JuliaDiff/ForwardDiff.jl"><code>ForwardDiff</code></a>.</p><p><strong>Examples</strong></p><p>Here we compute the Jacobian of a single-layer neural network <span>$x \to \mathrm{tanh}(Wx + b)$</span>. Its element-wise derivative is:</p><p class="math-container">\[    \frac{\partial}{\partial_i}\sigma(\sum_{k}w_{jk}x_k + b_j) = \sigma&#39;(\sum_{k}w_{jk}x_k + b_j)w_{ji}.\]</p><p>Also note that for this calculation <span>$\mathrm{tanh}(x) = \frac{e^{2x} - 1}{e^{2x} + 1}$</span> and <span>$\mathrm{tanh}&#39;(x) = \frac{4e^{2x}}{(e^{2x} + 1)^2}.$</span></p><p>We can use <code>Jacobian</code> together with <a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{AbstractArray{&lt;:Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>build_nn_function</code></a>:</p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks
using SymbolicNeuralNetworks: Jacobian, derivative
using AbstractNeuralNetworks: Dense, Chain, NeuralNetwork
using Symbolics
import Random

Random.seed!(123)

input_dim = 5
output_dim = 2
d = Dense(input_dim, 2, tanh)
c = Chain(d)
nn = SymbolicNeuralNetwork(c)
□ = SymbolicNeuralNetworks.Jacobian(nn)
# here we need to access the derivative and convert it into a function
jacobian1 = build_nn_function(derivative(□), nn)
ps = NeuralNetwork(c, Float64).params
input = rand(input_dim)
#derivative
Dtanh(x::Real) = 4 * exp(2 * x) / (1 + exp(2x)) ^ 2
analytic_jacobian(i, j) = Dtanh(sum(k -&gt; ps.L1.W[j, k] * input[k], 1:input_dim) + ps.L1.b[j]) * ps.L1.W[j, i]
jacobian1(input, ps) ≈ [analytic_jacobian(i, j) for j ∈ 1:output_dim, i ∈ 1:input_dim]

# output

true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/derivatives/jacobian.jl#L1-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.SymbolicNeuralNetwork" href="#SymbolicNeuralNetworks.SymbolicNeuralNetwork"><code>SymbolicNeuralNetworks.SymbolicNeuralNetwork</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SymbolicNeuralNetwork &lt;: AbstractSymbolicNeuralNetwork</code></pre><p>A symbolic neural network realizes a symbolic represenation (of small neural networks).</p><p><strong>Fields</strong></p><p>The <code>struct</code> has the following fields:</p><ul><li><code>architecture</code>: the neural network architecture,</li><li><code>model</code>: the model (typically a Chain that is the realization of the architecture),</li><li><code>params</code>: the symbolic parameters of the network.</li><li><code>sinput</code>: the symbolic input of the network.</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">SymbolicNeuralNetwork(nn)</code></pre><p>Make a <code>SymbolicNeuralNetwork</code> based on a <code>AbstractNeuralNetworks.Network</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/symbolic_neuralnet/symbolic_neuralnet.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.SymbolicPullback" href="#SymbolicNeuralNetworks.SymbolicPullback"><code>SymbolicNeuralNetworks.SymbolicPullback</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SymbolicPullback &lt;: AbstractPullback</code></pre><p><code>SymbolicPullback</code> computes the <em>symbolic pullback</em> of a loss function.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks
using AbstractNeuralNetworks
using AbstractNeuralNetworks: params
import Random
Random.seed!(123)

c = Chain(Dense(2, 1, tanh))
nn = NeuralNetwork(c)
snn = SymbolicNeuralNetwork(nn)
loss = FeedForwardLoss()
pb = SymbolicPullback(snn, loss)
ps = params(nn)
typeof(pb(ps, nn.model, (rand(2), rand(1)))[2](1))

# output

@NamedTuple{L1::@NamedTuple{W::Matrix{Float64}, b::Vector{Float64}}}</code></pre><p><strong>Implementation</strong></p><p>An instance of <code>SymbolicPullback</code> stores</p><ul><li><code>loss</code>: an instance of a <code>NetworkLoss</code>,</li><li><code>fun</code>: a function that is used to compute the pullback.</li></ul><p>If we call the functor of an instance of <code>SymbolicPullback</code> on <code>model</code>, <code>ps</code> and <code>input</code> it returns:</p><pre><code class="language-julia hljs">_pullback.loss(model, ps, input...), _pullback.fun(input..., ps)</code></pre><p>where the second output argument is again a function.</p><p><strong>Extended help</strong></p><p>We note the following seeming peculiarity:</p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks
using AbstractNeuralNetworks: Chain, Dense, NeuralNetwork, FeedForwardLoss, params
using Symbolics
import Random
Random.seed!(123)

c = Chain(Dense(2, 1, tanh))
nn = NeuralNetwork(c)
snn = SymbolicNeuralNetwork(nn)
loss = FeedForwardLoss()
pb = SymbolicPullback(snn, loss)
input_output = (rand(2), rand(1))
loss_and_pullback = pb(params(nn), nn.model, input_output)
# note that we apply the second argument to another input `1`
pb_values = loss_and_pullback[2](1)

@variables soutput[1:SymbolicNeuralNetworks.output_dimension(nn.model)]
symbolic_pullbacks = SymbolicNeuralNetworks.symbolic_pullback(loss(nn.model, params(snn), snn.input, soutput), snn)
pb_values2 = build_nn_function(symbolic_pullbacks, params(snn), snn.input, soutput)(input_output[1], input_output[2], params(nn))

pb_values == (pb_values2 |&gt; SymbolicNeuralNetworks._get_contents |&gt; SymbolicNeuralNetworks._get_params)

# output

true</code></pre><p>See the docstrings for <a href="#SymbolicNeuralNetworks.symbolic_pullback-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}"><code>symbolic_pullback</code></a>, <a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{AbstractArray{&lt;:Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>build_nn_function</code></a>, <a href="#SymbolicNeuralNetworks._get_params-Tuple{NamedTuple}"><code>_get_params</code></a> and <a href="#SymbolicNeuralNetworks._get_contents-Tuple{NamedTuple}"><code>_get_contents</code></a> for more info on the functions that we used here. The noteworthy thing in the expression above is that the functor of <code>SymbolicPullback</code> returns two objects: the first one is the loss value evaluated for the relevant parameters and inputs. The second one is a function that takes again an input argument and then finally returns the partial derivatives. But why do we need this extra step with another function?</p><div class="admonition is-info"><header class="admonition-header">Reverse Accumulation</header><div class="admonition-body"><p>In machine learning we typically do <a href="https://en.wikipedia.org/wiki/Automatic_differentiation#Forward_and_reverse_accumulation">reverse accumulation</a> to perform automatic differentiation (AD). Assuming we are given a function that is the composition of simpler functions <span>$f = f_1\circ{}f_2\circ\cdots\circ{}f_n:\mathbb{R}^n\to\mathbb{R}^m$</span> <em>reverse differentiation</em> starts with <em>output sensitivities</em> and then successively feeds them through <span>$f_n$</span>, <span>$f_{n-1}$</span> etc. So it does:</p><p class="math-container">\[(\nabla_xf)^T = (\nabla_{x}f_1)^T(\nabla_{f_1(x)}f_2)^T\cdots(\nabla_{f_{n-1}(\cdots{}x)}f_n)^T(do),\]</p><p>where <span>$do\in\mathbb{R}^m$</span> are the <em>output sensitivities</em> and the jacobians are stepwise multiplied from the left. So we propagate from the output stepwise back to the input. If we have <span>$m=1$</span>, i.e. if the output is one-dimensional, then the <em>output sensitivities</em> may simply be taken to be <span>$do = 1$</span>.</p></div></div><p>So in theory we could leave out this extra step: returning an object (that is stored in <code>pb.fun</code>) can be seen as unnecessary as we could simply store the equivalent of <code>pb.fun(1.)</code> in an instance of <code>SymbolicPullback</code>. It is however customary for a pullback to return a callable function (that depends on the <em>output sensitivities</em>), which is why we also choose to do this here, even if the <em>output sensitivities</em> are a scalar quantity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/derivatives/pullback.jl#L1-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr, Symbolics.Arr}" href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr, Symbolics.Arr}"><code>SymbolicNeuralNetworks._build_nn_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_build_nn_function(eq, params, sinput, soutput)</code></pre><p>Build a function that can process a matrix. See <a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{AbstractArray{&lt;:Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>build_nn_function(::EqT, ::NeuralNetworkParameters, ::Symbolics.Arr)</code></a>.</p><p><strong>Implementation</strong></p><p>Note that we have two input arguments here which means this method processes code differently than <a href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr, Symbolics.Arr}"><code>_build_nn_function(::EqT, ::NeuralNetworkParameters, ::Symbolics.Arr, ::Symbolics.Arr)</code></a>. Here we call:</p><ol><li><a href="#SymbolicNeuralNetworks.fix_create_array-Tuple{AbstractString}"><code>fix_create_array</code></a>,</li><li><a href="#SymbolicNeuralNetworks.rewrite_arguments2-Tuple{AbstractString}"><code>rewrite_arguments2</code></a>,</li><li><a href="#SymbolicNeuralNetworks.modify_input_arguments2-Tuple{AbstractString}"><code>modify_input_arguments2</code></a>,</li><li><a href="#SymbolicNeuralNetworks.fix_map_reduce-Tuple{AbstractString}"><code>fix_map_reduce</code></a>.</li></ol><p>See the docstrings for those functions for details on how the code is modified. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function_double_input.jl#L27-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr}" href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr}"><code>SymbolicNeuralNetworks._build_nn_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_build_nn_function(eq, params, sinput)</code></pre><p>Build a function that can process a matrix. This is used as a starting point for <a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{AbstractArray{&lt;:Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>build_nn_function</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: _build_nn_function, SymbolicNeuralNetwork
using AbstractNeuralNetworks: params, Chain, Dense, NeuralNetwork
import Random
Random.seed!(123)

c = Chain(Dense(2, 1, tanh))
nn = NeuralNetwork(c)
snn = SymbolicNeuralNetwork(nn)
eq = c(snn.input, params(snn))
built_function = _build_nn_function(eq, params(snn), snn.input)
built_function([1. 2.; 3. 4.], params(nn), 1)

# output

1-element Vector{Float64}:
 -0.9999967113439513</code></pre><p>Note that we have to supply an extra argument (index) to <code>_build_nn_function</code> that we do not have to supply to <a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{AbstractArray{&lt;:Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>build_nn_function</code></a>.</p><p><strong>Implementation</strong></p><p>This first calls <code>Symbolics.build_function</code> with the keyword argument <code>expression = Val{true}</code> and then modifies the generated code by calling:</p><ol><li><a href="#SymbolicNeuralNetworks.fix_create_array-Tuple{AbstractString}"><code>fix_create_array</code></a>,</li><li><a href="#SymbolicNeuralNetworks.rewrite_arguments-Tuple{AbstractString}"><code>rewrite_arguments</code></a>,</li><li><a href="#SymbolicNeuralNetworks.modify_input_arguments-Tuple{AbstractString}"><code>modify_input_arguments</code></a>,</li><li><a href="#SymbolicNeuralNetworks.fix_map_reduce-Tuple{AbstractString}"><code>fix_map_reduce</code></a>.</li></ol><p>See the docstrings for those functions for details on how the code is modified. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function.jl#L34-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks._get_contents-Tuple{NamedTuple}" href="#SymbolicNeuralNetworks._get_contents-Tuple{NamedTuple}"><code>SymbolicNeuralNetworks._get_contents</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_contents(nt::AbstractArray{&lt;:NamedTuple})</code></pre><p>Return the contents of a one-dimensional vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: _get_contents

_get_contents([(a = &quot;element_contained_in_vector&quot;, )])

# output

(a = &quot;element_contained_in_vector&quot;,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/derivatives/pullback.jl#L115-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks._get_params-Tuple{NamedTuple}" href="#SymbolicNeuralNetworks._get_params-Tuple{NamedTuple}"><code>SymbolicNeuralNetworks._get_params</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_params(ps::NeuralNetworkParameters)</code></pre><p>Return the <code>NamedTuple</code> that&#39;s equivalent to the <code>NeuralNetworkParameters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/derivatives/pullback.jl#L105-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks._modify_integer-Tuple{AbstractString}" href="#SymbolicNeuralNetworks._modify_integer-Tuple{AbstractString}"><code>SymbolicNeuralNetworks._modify_integer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_modify_integer</code></pre><p>If the input is a single integer, subtract 1 from it.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: _modify_integer

s = [&quot;2&quot;, &quot;hello&quot;, &quot;hello2&quot;, &quot;3&quot;]
_modify_integer.(s)

# output
4-element Vector{String}:
 &quot;1&quot;
 &quot;hello&quot;
 &quot;hello2&quot;
 &quot;2&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function.jl#L135-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks._modify_integer2-Tuple{AbstractString}" href="#SymbolicNeuralNetworks._modify_integer2-Tuple{AbstractString}"><code>SymbolicNeuralNetworks._modify_integer2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_modify_integer2</code></pre><p>If the input is a single integer, subtract 2 from it.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: _modify_integer2

s = [&quot;3&quot;, &quot;hello&quot;, &quot;hello2&quot;, &quot;4&quot;]
_modify_integer2.(s)

# output
4-element Vector{String}:
 &quot;1&quot;
 &quot;hello&quot;
 &quot;hello2&quot;
 &quot;2&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function_double_input.jl#L140-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks._reduce_code-Tuple{Expr}" href="#SymbolicNeuralNetworks._reduce_code-Tuple{Expr}"><code>SymbolicNeuralNetworks._reduce_code</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_reduce_code(code)</code></pre><p>Reduce the code.</p><p>For some reason <code>Symbolics.build_function</code> sometimes returns a tuple and sometimes it doesn&#39;t.</p><p>This function takes care of this.  If <code>build_function</code> returns a tuple <code>reduce_code</code> checks which of the expressions is in-place and then returns the other (not in-place) expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function.jl#L80-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.apply_element_wise-Tuple{AbstractArray, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{AbstractArray}}" href="#SymbolicNeuralNetworks.apply_element_wise-Tuple{AbstractArray, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{AbstractArray}}"><code>SymbolicNeuralNetworks.apply_element_wise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_element_wise(ps, params, input...)</code></pre><p>Apply a function element-wise. <code>ps</code> is an <code>Array</code> where each entry of the array is are <code>NeuralNetworkParameters</code> that store functions. See <a href="#SymbolicNeuralNetworks.apply_element_wise-Tuple{AbstractNeuralNetworks.NeuralNetworkParameters, AbstractNeuralNetworks.NeuralNetworkParameters, Any}"><code>apply_element_wise(::NeuralNetworkParameters, ::NeuralNetworkParameters, ::Any)</code></a>.</p><p><strong>Examples</strong></p><p>Vector: </p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: apply_element_wise
using AbstractNeuralNetworks: NeuralNetworkParameters

# parameter values
params = NeuralNetworkParameters((a = 1., b = 2.))
ps = [NeuralNetworkParameters((val1 = (input, params) -&gt; input .+ params.a, val2 = (input, params) -&gt; input .+ params.b))]
apply_element_wise(ps, params, [1.])

# output

1-element Vector{NeuralNetworkParameters{(:val1, :val2), Tuple{Vector{Float64}, Vector{Float64}}}}:
 NeuralNetworkParameters{(:val1, :val2), Tuple{Vector{Float64}, Vector{Float64}}}((val1 = [2.0], val2 = [3.0]))</code></pre><p>Matrix: </p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: apply_element_wise
using AbstractNeuralNetworks: NeuralNetworkParameters

# parameter values
params = NeuralNetworkParameters((a = 1., b = 2.))
sc_ps = NeuralNetworkParameters((val1 = (input, params) -&gt; input .+ params.a, val2 = (input, params) -&gt; input .+ params.b))
ps = [sc_ps sc_ps]
apply_element_wise(ps, params, [1.]) |&gt; typeof

# output

Matrix{NeuralNetworkParameters{(:val1, :val2), Tuple{Vector{Float64}, Vector{Float64}}}} (alias for Array{NeuralNetworkParameters{(:val1, :val2), Tuple{Array{Float64, 1}, Array{Float64, 1}}}, 2})</code></pre><p><strong>Implementation</strong></p><p>This is generating a <code>@generated function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function_arrays.jl#L117-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.apply_element_wise-Tuple{AbstractNeuralNetworks.NeuralNetworkParameters, AbstractNeuralNetworks.NeuralNetworkParameters, Any}" href="#SymbolicNeuralNetworks.apply_element_wise-Tuple{AbstractNeuralNetworks.NeuralNetworkParameters, AbstractNeuralNetworks.NeuralNetworkParameters, Any}"><code>SymbolicNeuralNetworks.apply_element_wise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_element_wise(ps, params, input...)</code></pre><p>Apply a function element-wise. <code>ps</code> is a <code>NeuralNetworkParameters</code>-valued function.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: apply_element_wise
using AbstractNeuralNetworks: NeuralNetworkParameters

# parameter values
params = NeuralNetworkParameters((a = 1., b = 2.))
ps = NeuralNetworkParameters((val1 = (input, params) -&gt; input + params.a, val2 = (input, params) -&gt; input + params.b))
apply_element_wise(ps, params, 1.)

# output

NeuralNetworkParameters{(:val1, :val2), Tuple{Float64, Float64}}((val1 = 2.0, val2 = 3.0))</code></pre><p><strong>Implementation</strong></p><p>This is generating a <code>@generated function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function_arrays.jl#L209-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.build_nn_function-Tuple{AbstractArray{&lt;:Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}" href="#SymbolicNeuralNetworks.build_nn_function-Tuple{AbstractArray{&lt;:Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>SymbolicNeuralNetworks.build_nn_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_nn_function(eqs::AbstractArray{&lt;:NeuralNetworkParameters}, sparams, sinput...)</code></pre><p>Build an executable function based on an array of symbolic equations <code>eqs</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: build_nn_function, SymbolicNeuralNetwork
using AbstractNeuralNetworks: Chain, Dense, NeuralNetwork, params
import Random
Random.seed!(123)

ch = Chain(Dense(2, 1, tanh))
nn = NeuralNetwork(ch)
snn = SymbolicNeuralNetwork(nn)
eqs = [(a = ch(snn.input, params(snn)), b = ch(snn.input, params(snn)).^2), (c = ch(snn.input, params(snn)).^3, )]
funcs = build_nn_function(eqs, params(snn), snn.input)
input = [1., 2.]
funcs_evaluated = funcs(input, params(nn))

# output

2-element Vector{NamedTuple}:
 (a = [-0.9999386280616135], b = [0.9998772598897417])
 (c = [-0.9998158954841537],)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function_arrays.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.build_nn_function-Tuple{Any, AbstractSymbolicNeuralNetwork, Any}" href="#SymbolicNeuralNetworks.build_nn_function-Tuple{Any, AbstractSymbolicNeuralNetwork, Any}"><code>SymbolicNeuralNetworks.build_nn_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_nn_function(eqs, nn, soutput)</code></pre><p>Build an executable function that can also depend on an output. It is then called with:</p><pre><code class="language-julia hljs">built_function(input, output, ps)</code></pre><p>Also compare this to <a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}"><code>build_nn_function(::EqT, ::AbstractSymbolicNeuralNetwork)</code></a>.</p><p><strong>Extended Help</strong></p><p>See the <em>extended help section</em> of <a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}"><code>build_nn_function(::EqT, ::AbstractSymbolicNeuralNetwork)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function_double_input.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.build_nn_function-Tuple{Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}" href="#SymbolicNeuralNetworks.build_nn_function-Tuple{Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>SymbolicNeuralNetworks.build_nn_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_nn_function(eqs::Union{NamedTuple, NeuralNetworkParameters}, sparams, sinput...)</code></pre><p>Return a function that takes an input, (optionally) an output and neural network parameters and returns a <code>NeuralNetworkParameters</code>-valued output.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: build_nn_function, SymbolicNeuralNetwork
using AbstractNeuralNetworks: Chain, Dense, NeuralNetwork, params
import Random
Random.seed!(123)

c = Chain(Dense(2, 1, tanh))
nn = NeuralNetwork(c)
snn = SymbolicNeuralNetwork(nn)
eqs = (a = c(snn.input, params(snn)), b = c(snn.input, params(snn)).^2)
funcs = build_nn_function(eqs, params(snn), snn.input)
input = [1., 2.]
funcs_evaluated = funcs(input, params(nn))

# output

(a = [-0.9999386280616135], b = [0.9998772598897417])</code></pre><p><strong>Implementation</strong></p><p>Internally this is using <a href="#SymbolicNeuralNetworks.function_valued_parameters-Tuple{AbstractNeuralNetworks.NeuralNetworkParameters, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>function_valued_parameters</code></a> and <a href="#SymbolicNeuralNetworks.apply_element_wise-Tuple{AbstractArray, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{AbstractArray}}"><code>apply_element_wise</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function_arrays.jl#L38-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}" href="#SymbolicNeuralNetworks.build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}"><code>SymbolicNeuralNetworks.build_nn_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_nn_function(eq, nn)</code></pre><p>Build an executable function based on a symbolic equation, a symbolic input array and a <a href="#SymbolicNeuralNetworks.SymbolicNeuralNetwork"><code>SymbolicNeuralNetwork</code></a>.</p><p>This function can be called with:</p><pre><code class="language-julia hljs">built_function(input, ps)</code></pre><p><strong>Implementation</strong></p><p>Internally this is calling <a href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr, Symbolics.Arr}"><code>_build_nn_function</code></a> and then <em>parallelizing</em> the expression via the index <code>k</code>.</p><p><strong>Extended Help</strong></p><p>The functions mentioned in the implementation section were adjusted ad-hoc to deal with problems that emerged on the fly.  Other problems may occur. In case you bump into one please <a href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/issues">open an issue on github</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.derivative-Tuple{SymbolicNeuralNetworks.Gradient}" href="#SymbolicNeuralNetworks.derivative-Tuple{SymbolicNeuralNetworks.Gradient}"><code>SymbolicNeuralNetworks.derivative</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">derivative(g)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: SymbolicNeuralNetwork, Gradient, derivative, symbolic_pullback
using AbstractNeuralNetworks

c = Chain(Dense(2, 1, tanh))
nn = SymbolicNeuralNetwork(c)
g = Gradient(nn)
∇ = derivative(g)

isequal(∇, symbolic_pullback(g.output, nn))

# output

true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/derivatives/gradient.jl#L49-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.fix_create_array-Tuple{AbstractString}" href="#SymbolicNeuralNetworks.fix_create_array-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.fix_create_array</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>fix<em>create</em>array(s)</p><p>Fix a problem that occurs in connection with <code>create_array</code>.</p><p>The function <code>create_array</code> from <code>SymbolicUtils.Code</code> takes as first input the type of a symbolic array.  For reasons that are not entirely clear yet the first argument of <code>create_array</code> ends up being <code>ˍ₋arg2</code>, which is a <code>NamedTuple</code> of symoblic arrays. We solve this problem by replacing <code>typeof(ˍ₋arg[0-9]+)</code> with <code>Array</code>, which seems to be the most generic possible input to <code>create_array</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: fix_create_array

s = &quot;(SymbolicUtils.Code.create_array)(typeof(ˍ₋arg2)&quot;
fix_create_array(s)

# output

&quot;SymbolicUtils.Code.create_array(typeof(sinput)&quot;</code></pre><p><strong>Implementation</strong></p><p>This is used for <a href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr}"><code>_build_nn_function(::EqT, ::NeuralNetworkParameters, ::Symbolics.Arr)</code></a> and <a href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr, Symbolics.Arr}"><code>_build_nn_function(::EqT, ::NeuralNetworkParameters, ::Symbolics.Arr, ::Symbolics.Arr)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function.jl#L188-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.fix_map_reduce-Tuple{AbstractString}" href="#SymbolicNeuralNetworks.fix_map_reduce-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.fix_map_reduce</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fix_map_reduce(s)</code></pre><p>Replace <code>Symbolics._mapreduce</code> with <code>mapreduce</code> (from <code>Base</code>).</p><p>When we generate a function with <code>Symbolics.build_function</code> it often contains <code>Symbolics._mapreduce</code> which cannot be differentiated with Zygote.  We get around this by replacing <code>Symbolics._mapreduce</code> with <code>mapreduce</code> and also doing:</p><pre><code class="language-julia hljs">replace(s, &quot;, Colon(), (:init =&gt; false,)&quot; =&gt; &quot;, dims = Colon()&quot;)</code></pre><p><strong>Implementation</strong></p><p>This is used for <a href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr}"><code>_build_nn_function(::EqT, ::NeuralNetworkParameters, ::Symbolics.Arr)</code></a> and <a href="#SymbolicNeuralNetworks._build_nn_function-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractNeuralNetworks.NeuralNetworkParameters, Symbolics.Arr, Symbolics.Arr}"><code>_build_nn_function(::EqT, ::NeuralNetworkParameters, ::Symbolics.Arr, ::Symbolics.Arr)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function.jl#L224-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.function_valued_parameters-Tuple{AbstractNeuralNetworks.NeuralNetworkParameters, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}" href="#SymbolicNeuralNetworks.function_valued_parameters-Tuple{AbstractNeuralNetworks.NeuralNetworkParameters, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>SymbolicNeuralNetworks.function_valued_parameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function_valued_parameters(eqs::Union{NamedTuple, NeuralNetworkParameters}, sparams, sinput...)</code></pre><p>Return an executable function for each entry in <code>eqs</code>. This still has to be processed with <a href="#SymbolicNeuralNetworks.apply_element_wise-Tuple{AbstractArray, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{AbstractArray}}"><code>apply_element_wise</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: function_valued_parameters, SymbolicNeuralNetwork
using AbstractNeuralNetworks: Chain, Dense, NeuralNetwork, params
import Random
Random.seed!(123)

c = Chain(Dense(2, 1, tanh))
nn = NeuralNetwork(c)
snn = SymbolicNeuralNetwork(nn)
eqs = (a = c(snn.input, params(snn)), b = c(snn.input, params(snn)).^2)
funcs = function_valued_parameters(eqs, params(snn), snn.input)
input = [1., 2.]
ps = params(nn)
a = c(input, ps)
b = c(input, ps).^2

(funcs.a(input, ps), funcs.b(input, ps)) .≈ (a, b)

# output

(true, true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function_arrays.jl#L77-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.make_kernel-Tuple{AbstractString}" href="#SymbolicNeuralNetworks.make_kernel-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.make_kernel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks

s = &quot;function (sinput, ps)\n begin\n getindex(sinput, 1) + getindex(sinput, 2) \n end\n end&quot;
SymbolicNeuralNetworks.make_kernel(s)

# output

&quot;function (sinput, ps, k)\n begin\n getindex(sinput, 1, k) + getindex(sinput, 2, k) \n end\n end&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function.jl#L248-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.make_kernel2-Tuple{AbstractString}" href="#SymbolicNeuralNetworks.make_kernel2-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.make_kernel2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks

s = &quot;function (sinput, soutput, ps)\n begin\n getindex(sinput, 1) + getindex(soutput, 2) \n end\n end&quot;
SymbolicNeuralNetworks.make_kernel2(s)

# output

&quot;function (sinput, soutput, ps, k)\n begin\n getindex(sinput, 1, k) + getindex(soutput, 2, k) \n end\n end&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function_double_input.jl#L79-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.modify_input_arguments-Tuple{AbstractString}" href="#SymbolicNeuralNetworks.modify_input_arguments-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.modify_input_arguments</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">modify_input_arguments(s)</code></pre><p>Change input arguments of type <code>(sinput, ps.L1, ps.L2)</code> etc to <code>(sinput, ps)</code>. This should be used after <a href="#SymbolicNeuralNetworks.rewrite_arguments-Tuple{AbstractString}"><code>rewrite_arguments</code></a>. Also see <a href="#SymbolicNeuralNetworks.build_nn_function-Tuple{AbstractArray{&lt;:Union{AbstractNeuralNetworks.NeuralNetworkParameters, NamedTuple}}, AbstractNeuralNetworks.NeuralNetworkParameters, Vararg{Symbolics.Arr}}"><code>build_nn_function</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: modify_input_arguments

s = &quot;(sinput, ps.L1, ps.L2, ps.L3)&quot;
modify_input_arguments(s)

# output
&quot;(sinput, ps)&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function.jl#L160-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.modify_input_arguments2-Tuple{AbstractString}" href="#SymbolicNeuralNetworks.modify_input_arguments2-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.modify_input_arguments2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">modify_input_arguments2(s)</code></pre><p>Change input arguments of type <code>(sinput, soutput, ps.L1, ps.L2)</code> etc to <code>(sinput, soutput, ps)</code>. This should be used after <a href="#SymbolicNeuralNetworks.rewrite_arguments-Tuple{AbstractString}"><code>rewrite_arguments</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: modify_input_arguments2

s = &quot;(sinput, soutput, ps.L1, ps.L2, ps.L3)&quot;
modify_input_arguments2(s)

# output
&quot;(sinput, soutput, ps)&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function_double_input.jl#L51-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.rewrite_arguments-Tuple{AbstractString}" href="#SymbolicNeuralNetworks.rewrite_arguments-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.rewrite_arguments</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rewrite_arguments(s)</code></pre><p>Replace <code>ˍ₋arg2</code>, <code>ˍ₋arg3</code>, ... with <code>ps.L1</code>, <code>ps.L2</code> etc. This is used after <code>Symbolics.build_function</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: rewrite_arguments
s = &quot;We test if strings that contain ˍ₋arg2 and ˍ₋arg3 can be converted in the right way.&quot;
rewrite_arguments(s)

# output
&quot;We test if strings that contain ps.L1 and ps.L2 can be converted in the right way.&quot;</code></pre><p><strong>Implementation</strong></p><p>The input is first split at the relevant points and then we call <a href="#SymbolicNeuralNetworks._modify_integer-Tuple{AbstractString}"><code>_modify_integer</code></a>. The routine <a href="#SymbolicNeuralNetworks._modify_integer-Tuple{AbstractString}"><code>_modify_integer</code></a> ensures that we start counting at 1 and not at 2. By defaut the arguments of the generated function that we get after applying <code>Symbolics.build_function</code> are <code>(x, ˍ₋arg2, ˍ₋arg3)</code> etc. We first change this to <code>(x, ps.L2, ps.L3)</code> etc. and then to <code>(x, ps.L1, ps.L2)</code> etc. via <a href="#SymbolicNeuralNetworks._modify_integer-Tuple{AbstractString}"><code>_modify_integer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function.jl#L98-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.rewrite_arguments2-Tuple{AbstractString}" href="#SymbolicNeuralNetworks.rewrite_arguments2-Tuple{AbstractString}"><code>SymbolicNeuralNetworks.rewrite_arguments2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rewrite_arguments2(s)</code></pre><p>Replace <code>ˍ₋arg3</code>, <code>ˍ₋arg4</code>, ... with <code>ps.L1</code>, <code>ps.L2</code> etc. Note that we subtract two from the input, unlike <a href="#SymbolicNeuralNetworks.rewrite_arguments-Tuple{AbstractString}"><code>rewrite_arguments</code></a> where it is one.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: rewrite_arguments2
s = &quot;We test if strings that contain ˍ₋arg3 and ˍ₋arg4 can be converted in the right way.&quot;
rewrite_arguments2(s)

# output
&quot;We test if strings that contain ps.L1 and ps.L2 can be converted in the right way.&quot;</code></pre><p><strong>Implementation</strong></p><p>The input is first split at the relevant points and then we call <a href="#SymbolicNeuralNetworks._modify_integer2-Tuple{AbstractString}"><code>_modify_integer2</code></a>. The routine <a href="#SymbolicNeuralNetworks._modify_integer2-Tuple{AbstractString}"><code>_modify_integer2</code></a> ensures that we start counting at 1 and not at 3. See <a href="#SymbolicNeuralNetworks.rewrite_arguments-Tuple{AbstractString}"><code>rewrite_arguments</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/build_function/build_function_double_input.jl#L104-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.symbolic_pullback-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}" href="#SymbolicNeuralNetworks.symbolic_pullback-Tuple{Union{Symbolics.Num, AbstractArray{Symbolics.Num}, AbstractArray{&lt;:SymbolicUtils.BasicSymbolic}}, AbstractSymbolicNeuralNetwork}"><code>SymbolicNeuralNetworks.symbolic_pullback</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symbolic_pullback(nn, output)</code></pre><p>This takes a symbolic output that depends on the parameters in <code>nn</code> and returns the corresponding pullback (a symbolic expression).</p><p>This is used by <a href="#SymbolicNeuralNetworks.Gradient"><code>Gradient</code></a> and <a href="#SymbolicNeuralNetworks.SymbolicPullback"><code>SymbolicPullback</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: SymbolicNeuralNetwork, symbolic_pullback
using AbstractNeuralNetworks
using AbstractNeuralNetworks: params
using LinearAlgebra: norm
using Latexify: latexify

c = Chain(Dense(2, 1, tanh))
nn = SymbolicNeuralNetwork(c)
output = c(nn.input, params(nn))
spb = symbolic_pullback(output, nn)

spb[1].L1.b |&gt; latexify

# output

L&quot;\begin{equation}
\left[
\begin{array}{c}
1 - \tanh^{2}\left( \mathtt{W\_2}_{1} + \mathtt{W\_1}_{1,1} \mathtt{sinput}_{1} + \mathtt{W\_1}_{1,2} \mathtt{sinput}_{2} \right) \\
\end{array}
\right]
\end{equation}
&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/derivatives/gradient.jl#L81-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.symboliccounter!-Tuple{Dict, Symbol}" href="#SymbolicNeuralNetworks.symboliccounter!-Tuple{Dict, Symbol}"><code>SymbolicNeuralNetworks.symboliccounter!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symboliccounter!(cache, arg; redundancy)</code></pre><p>Add a specific argument to the cache.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: symboliccounter!

cache = Dict()
var = symboliccounter!(cache, :var)
(cache, var)

# output
(Dict{Any, Any}(:var =&gt; 1), :var_1)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/symbolic_neuralnet/symbolize.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicNeuralNetworks.symbolize!" href="#SymbolicNeuralNetworks.symbolize!"><code>SymbolicNeuralNetworks.symbolize!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symbolize!(cache, nt, var_name)</code></pre><p>Symbolize all the arguments in <code>nt</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: symbolize!

cache = Dict()
sym = symbolize!(cache, .1, :X)
(sym, cache)

# output

(X_1, Dict{Any, Any}(:X =&gt; 1))</code></pre><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: symbolize!

cache = Dict()
arr = rand(2, 1)
sym_scalar = symbolize!(cache, .1, :X)
sym_array = symbolize!(cache, arr, :Y)
(sym_array, cache)

# output

(Y_1[Base.OneTo(2),Base.OneTo(1)], Dict{Any, Any}(:X =&gt; 1, :Y =&gt; 1))</code></pre><p>Note that the for the second case the cache is storing a scalar under <code>:X</code> and an array under <code>:Y</code>. If we use the same label for both we get:</p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: symbolize!

cache = Dict()
arr = rand(2, 1)
sym_scalar = symbolize!(cache, .1, :X)
sym_array = symbolize!(cache, arr, :X)
(sym_array, cache)

# output

(X_2[Base.OneTo(2),Base.OneTo(1)], Dict{Any, Any}(:X =&gt; 2))</code></pre><p>We can also use <code>symbolize!</code> with <code>NamedTuple</code>s:</p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: symbolize!

cache = Dict()
nt = (a = 1, b = [1, 2])
sym = symbolize!(cache, nt, :X)
(sym, cache)

# output

((a = X_1, b = X_2[Base.OneTo(2)]), Dict{Any, Any}(:X =&gt; 2))</code></pre><p>And for neural network parameters:</p><pre><code class="language-julia hljs">using SymbolicNeuralNetworks: symbolize!
using AbstractNeuralNetworks: NeuralNetwork, params, Chain, Dense

nn = NeuralNetwork(Chain(Dense(1, 2; use_bias = false), Dense(2, 1; use_bias = false)))
cache = Dict()
sym = symbolize!(cache, params(nn), :X) |&gt; typeof

# output

AbstractNeuralNetworks.NeuralNetworkParameters{(:L1, :L2), Tuple{@NamedTuple{W::Symbolics.Arr{Symbolics.Num, 2}}, @NamedTuple{W::Symbolics.Arr{Symbolics.Num, 2}}}}</code></pre><p><strong>Implementation</strong></p><p>Internally this is using <a href="#SymbolicNeuralNetworks.symboliccounter!-Tuple{Dict, Symbol}"><code>symboliccounter!</code></a>. This function is also adjusting/altering the <code>cache</code> (that is optionally supplied as an input argument).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/SymbolicNeuralNetworks.jl/blob/26565f0af134e14d326717974376b4724391462f/src/symbolic_neuralnet/symbolize.jl#L30-L112">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="symbolic_neural_networks/">Vanilla Symbolic Neural Network »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Thursday 13 February 2025 12:13">Thursday 13 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
